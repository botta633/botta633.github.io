<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Container Trinity: Namespaces, cgroups, & Layered FS - Botta's Blog</title>
    <link rel="stylesheet" href="styles.css">
</head>

<body>
<header class="header">
    <div class="logo">Code Chronicles</div>
    <nav class="nav">
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="software.html">Software Blog</a></li>
            <li><a href="life.html">Life Blog</a></li>
        </ul>
    </nav>
</header>

<main class="article-page">
    <section class="article-hero">
        <div class="article-category">Kernel Internals</div>
        <h1>The Container Trinity: Namespaces, cgroups, and Layered FS</h1>
        <p class="article-subtitle">
            Dissecting the three Linux kernel features that create the illusion of a standalone container.
        </p>
        <div class="article-meta">
            <span class="meta-pill">Published: December 27, 2025</span>
            <span class="meta-pill">Reading time: 15 minutes</span>
            <span class="meta-pill">Stack: Linux / C / OverlayFS</span>
        </div>
        <div class="article-hero-actions">
            <a href="software.html" class="button-cyber">Back to Software Blog</a>
        </div>
    </section>

    <section class="article-content">
        <div class="content-block">
            <h2 class="section-title">Executive Summary</h2>
            <p>
                A "container" does not exist as a first-class object in the Linux kernel. It is a userspace concept realized by combining three distinct kernel features: <strong>Namespaces</strong> (what you can see), <strong>Control Groups</strong> (what you can use), and <strong>Layered File Systems</strong> (how you store data).
            </p>
            <p>
                In this post, we provide a high-level architectural overview of this trinity. This is the <strong>Part 1</strong> foundation; we will be releasing deep-dive articles for each specific component in the coming weeks.
            </p>
        </div>

        <div class="content-block">
            <h2 class="section-title">The Illusion of Isolation</h2>
            <p>
                Traditional virtualization (VMs) relies on hypervisors to emulate hardware, which introduces significant overhead in boot time and memory footprint because you are running a full OS kernel on top of another kernel. Containers take a different approach: they share the host kernel but lie to the process about the resources it sees.
            </p>
            
            

            <div class="callout-grid">
                <div class="callout-card">
                    <h3>1. Namespaces</h3>
                    <p><strong>The Walls.</strong> They limit the <em>visibility</em> of system resources (PIDs, Mounts, Network).</p>
                </div>
                <div class="callout-card">
                    <h3>2. Cgroups</h3>
                    <p><strong>The Budget.</strong> They limit the <em>usage</em> of physical resources (CPU, RAM, Disk I/O).</p>
                </div>
                <div class="callout-card">
                    <h3>3. Layered FS</h3>
                    <p><strong>The Floorplan.</strong> They provide the <em>efficiency</em> of storage via Copy-on-Write (CoW).</p>
                </div>
            </div>
        </div>

        <div class="content-block">
            <h2 class="section-title">1. Namespaces: The Walls</h2>
            <p>
                <strong>Role:</strong> Namespaces wrap global system resources in an abstraction that makes it appear to the processes within the namespace that they have their own isolated instance of the global resource.
            </p>
            <p>
                <strong>Mechanism:</strong> When you clone a process with the <code>CLONE_NEWPID</code> flag, the kernel creates a new PID namespace. Inside this new scope, the process sees itself as PID 1 (the init process). However, in the host's root namespace, that same process might be PID 4523. This mapping allows the kernel to maintain a global truth while presenting a local view to the container.
            </p>
            
            

            <p>
                Other critical namespaces include:
            </p>
            <ul>
                <li><strong>MNT (Mount):</strong> Allows the container to have its own root filesystem (<code>/</code>) independent of the host.</li>
                <li><strong>NET (Network):</strong> Gives the container its own <code>eth0</code>, IP address, and routing table.</li>
                <li><strong>UTS:</strong> Allows the container to have its own hostname.</li>
            </ul>

            <div class="code-block">
<pre><code><span class="code-comment">// minimal_container.c - Creating a namespace</span>
<span class="code-keyword">#define</span> _GNU_SOURCE
<span class="code-keyword">#include</span> &lt;sched.h&gt;
<span class="code-comment">// ... standard headers ...</span>

<span class="code-keyword">static</span> <span class="code-type">int</span> <span class="code-function">child_fn</span>(<span class="code-type">void</span> *arg) {
    <span class="code-comment">// To this process, it is PID 1</span>
    <span class="code-function">printf</span>(<span class="code-string">"PID inside container: %ld\n"</span>, (<span class="code-type">long</span>)<span class="code-function">getpid</span>());
    <span class="code-function">sethostname</span>(<span class="code-string">"container-node"</span>, <span class="code-number">14</span>);
    <span class="code-function">execlp</span>(<span class="code-string">"/bin/bash"</span>, <span class="code-string">"/bin/bash"</span>, NULL);
    <span class="code-keyword">return</span> <span class="code-number">0</span>;
}

<span class="code-type">int</span> <span class="code-function">main</span>() {
    <span class="code-comment">// CLONE_NEWPID | CLONE_NEWUTS creates the "Walls"</span>
    <span class="code-type">pid_t</span> child_pid = <span class="code-function">clone</span>(child_fn, stack + <span class="code-number">1048576</span>, 
        CLONE_NEWPID | CLONE_NEWUTS | SIGCHLD, NULL);
    <span class="code-function">waitpid</span>(child_pid, NULL, <span class="code-number">0</span>);
    <span class="code-keyword">return</span> <span class="code-number">0</span>;
}</code></pre>
            </div>
            <p><em>Coming soon in Part 2: We will deep dive into `struct nsproxy` and manually construct a networking namespace.</em></p>
        </div>

        <div class="content-block">
            <h2 class="section-title">2. cgroups: The Budget</h2>
            <p>
                <strong>Role:</strong> While namespaces hide processes from each other, they don't stop one container from eating all the host's RAM. This is where Control Groups (cgroups) come in. They organize processes into a hierarchy and impose limits on CPU cycles, memory usage, and block I/O.
            </p>
            <p>
                <strong>Mechanism:</strong> In cgroup v2, the kernel associates every process with a <code>css_set</code> (Control Group Subsystem State). The scheduler checks these states before allocating CPU time. If a group exceeds its `memory.max`, the Kernel OOM (Out of Memory) Killer triggers within that specific cgroup, killing the container process to save the host.
            </p>

            

            <div class="code-block">
<pre><code><span class="code-comment"># Interaction is done via the virtual filesystem /sys/fs/cgroup</span>

<span class="code-comment"># 1. Create the group (budget bucket)</span>
mkdir /sys/fs/cgroup/my_container

<span class="code-comment"># 2. Set the budget (20% CPU, 512MB RAM)</span>
echo "20000 100000" > /sys/fs/cgroup/my_container/cpu.max
echo "536870912" > /sys/fs/cgroup/my_container/memory.max

<span class="code-comment"># 3. Assign the process to the budget</span>
echo $$ > /sys/fs/cgroup/my_container/cgroup.procs</code></pre>
            </div>
            <p><em>Coming soon in Part 3: A practical guide to cgroup v2, OOM killer mechanics, and noisy neighbor prevention.</em></p>
        </div>

        <div class="content-block">
            <h2 class="section-title">3. Layered Filesystems (OverlayFS): The Floorplan</h2>
            <p>
                <strong>Role:</strong> If we had to copy the entire 1GB Ubuntu root filesystem every time we started a container, it would be slow and wasteful. Layered filesystems like OverlayFS allow multiple containers to share a single read-only base image while giving each one its own writable scratchpad.
            </p>
            <p>
                <strong>Mechanism:</strong> OverlayFS uses a union mount to combine multiple directories:
            </p>
            <ul>
                <li><strong>LowerDir (Read-Only):</strong> The base OS image. Shared by everyone.</li>
                <li><strong>UpperDir (Read-Write):</strong> The container's private layer.</li>
                <li><strong>WorkDir:</strong> Internal scratch space for the kernel.</li>
            </ul>
            <p>
                When you write to a file that exists in the LowerDir, the kernel performs a <strong>Copy-on-Write (CoW)</strong> operation: it pauses the write, copies the file up to the UpperDir, and then applies the modification there.
            </p>

            

            <div class="code-block">
<pre><code><span class="code-comment"># Manually mounting an OverlayFS to simulate a container root</span>
mount -t overlay overlay \
  -o lowerdir=/var/lib/images/ubuntu_base, \
     upperdir=/var/lib/containers/c1/diff, \
     workdir=/var/lib/containers/c1/work \
  /var/lib/containers/c1/merged</code></pre>
            </div>
            <p><em>Coming soon in Part 4: Visualizing the "Copy-up" latency and how storage drivers affect database performance in containers.</em></p>
        </div>

        <div class="content-block">
            <h2 class="section-title">Series Roadmap</h2>
            <p>
                We've established the high-level theory. Over the next few weeks, we will break these down individually:
            </p>
            <div class="callout-grid">
                <div class="callout-card">
                    <h3>Next: Part 2</h3>
                    <p><strong>Namespaces in Depth:</strong> Coding a container runtime from zero in C.</p>
                </div>
                <div class="callout-card">
                    <h3>Then: Part 3</h3>
                    <p><strong>Mastering cgroups:</strong> Resource accounting and isolation strategies.</p>
                </div>
                <div class="callout-card">
                    <h3>Finally: Part 4</h3>
                    <p><strong>Storage Drivers:</strong> Overlay2, Btrfs, and the mechanics of image layers.</p>
                </div>
            </div>
        </div>

        <div class="content-block">
            <h2 class="section-title">Resources</h2>
            <ul class="resource-links">
                <li><a href="https://man7.org/linux/man-pages/man7/namespaces.7.html">Linux Man Pages: Namespaces</a></li>
                <li><a href="https://www.kernel.org/doc/Documentation/filesystems/overlayfs.txt">Kernel Docs: OverlayFS</a></li>
                <li><a href="https://man7.org/linux/man-pages/man7/cgroups.7.html">Cgroups v2 Documentation</a></li>
            </ul>
        </div>
    </section>
</main>
</body>

</html>